#!/usr/bin/env python3
"""
env_to_ssm.py

Read a .env file and generate either:
  - a Bash script with `aws ssm put-parameter` commands, or
  - a Terraform file with `aws_ssm_parameter` resources.

Usage:
  python env_to_ssm.py --env-file .env --prefix /foundry/dev --format bash > put_params.sh
  python env_to_ssm.py --env-file .env --prefix /foundry/dev --format tf   > secrets.tf
  python env_to_ssm.py --env-file .env --prefix /foundry/dev --format bash --overwrite > put_params.sh
"""

import argparse
import re
import sys
from pathlib import Path


def parse_env_file(path: Path) -> dict[str, str]:
    """Parse a .env file into a dict of {KEY: VALUE}.

    Handles:
    - Comments (lines starting with #)
    - Inline comments (removes # comment from end of line)
    - Single and double quoted values
    - Empty values
    """
    env = {}
    for line_num, line in enumerate(path.read_text().splitlines(), 1):
        original_line = line
        line = line.strip()

        # Skip empty lines and comments
        if not line or line.startswith("#"):
            continue

        # Handle KEY=VALUE (first '=' only)
        if "=" not in line:
            print(f"Warning: Skipping line {line_num} (no '=' found): {original_line}", file=sys.stderr)
            continue

        key, value = line.split("=", 1)
        key = key.strip()
        value = value.strip()

        # Validate key (env var names should be alphanumeric + underscore)
        if not re.match(r"^[A-Z_][A-Z0-9_]*$", key):
            print(f"Warning: Key '{key}' on line {line_num} doesn't match typical env var naming", file=sys.stderr)

        # Strip optional surrounding quotes
        if len(value) >= 2:
            if (value.startswith('"') and value.endswith('"')) or (value.startswith("'") and value.endswith("'")):
                value = value[1:-1]

        # Handle inline comments for unquoted values
        # If the original value wasn't quoted, strip inline comments
        if not (original_line.strip().split("=", 1)[1].strip().startswith(('"', "'"))):
            # Remove inline comment
            value = value.split("#")[0].strip()

        env[key] = value

    return env


def validate_ssm_parameter_name(name: str) -> bool:
    """Validate SSM parameter name meets AWS requirements.

    Requirements:
    - Max 2048 characters
    - Pattern: ^[a-zA-Z0-9_.-/]+$
    """
    if len(name) > 2048:
        return False
    if not re.match(r"^[a-zA-Z0-9_.\-/]+$", name):
        return False
    return True


def normalize_name_for_tf(key: str) -> str:
    """Convert ENV_VAR_NAME to env_var_name for Terraform resource names."""
    s = key.lower()
    s = re.sub(r"[^a-z0-9]+", "_", s)
    s = re.sub(r"_+", "_", s).strip("_")
    if not s:
        s = "param"
    # Terraform resource names can't start with a number
    if s[0].isdigit():
        s = "param_" + s
    return s


def bash_escape_single_quote(value: str) -> str:
    """Escape a value for use within single quotes in bash.

    In single quotes, the only character that needs escaping is the single quote itself.
    We use the '\'' technique: end quote, escaped quote, start quote.
    """
    return value.replace("'", "'\"'\"'")


def generate_bash(env_dict: dict[str, str], prefix: str, overwrite: bool = False, region: str = None) -> str:
    """Generate a bash script with aws ssm put-parameter calls.

    Uses single quotes to avoid shell expansion of $, `, etc.
    """
    prefix_clean = prefix.rstrip("/")

    lines = [
        "#!/usr/bin/env bash",
        "#",
        "# Generated by env_to_ssm.py",
        "# Writes .env values to AWS SSM Parameter Store",
        "#",
        "",
        "set -euo pipefail",
        "",
    ]

    if region:
        lines.extend(
            [
                f'AWS_REGION="{region}"',
                "export AWS_REGION",
                "",
            ]
        )

    lines.extend(
        [
            f'PREFIX="{prefix_clean}"',
            "",
            "# WARNING:",
            "# - This script writes your .env values into AWS SSM Parameter Store as SecureStrings.",
            "# - Verify you are in the correct AWS account and region before running.",
            "# - Run: aws sts get-caller-identity",
            "",
            'echo "AWS Account: $(aws sts get-caller-identity --query Account --output text)"',
            f'echo "AWS Region: ${{{(region and "AWS_REGION") or "AWS_DEFAULT_REGION:-us-east-1"}}}"',
            'echo "Prefix: $PREFIX"',
            'echo ""',
            'read -p "Continue? (y/N) " -n 1 -r',
            "echo",
            "if [[ ! $REPLY =~ ^[Yy]$ ]]; then",
            '    echo "Aborted."',
            "    exit 1",
            "fi",
            'echo ""',
            "",
        ]
    )

    invalid_params = []
    for key, value in sorted(env_dict.items()):
        param_name = f"{prefix_clean}/{key}"

        # Validate parameter name
        if not validate_ssm_parameter_name(param_name):
            invalid_params.append((key, param_name))
            continue

        # Use single quotes for safety (prevents variable expansion)
        safe_value = bash_escape_single_quote(value)

        overwrite_flag = "--overwrite" if overwrite else ""

        lines.extend(
            [
                f'echo "Writing {param_name}..."',
                "aws ssm put-parameter \\",
                f"  --name '{param_name}' \\",
                "  --type 'SecureString' \\",
                f"  --value '{safe_value}' \\",
                f"  {overwrite_flag}".rstrip(),
                "",
            ]
        )

    if invalid_params:
        lines.insert(0, "# WARNING: The following parameters have invalid names and were skipped:")
        for key, param_name in invalid_params:
            lines.insert(1, f"#   - {key} -> {param_name}")
        lines.insert(len(invalid_params) + 1, "")

    lines.append('echo ""')
    lines.append('echo "‚úì All parameters written successfully!"')

    return "\n".join(lines) + "\n"


def generate_terraform(env_dict: dict[str, str], prefix: str) -> str:
    """Generate Terraform aws_ssm_parameter resources.

    NOTE: This embeds values directly into HCL, which is sensitive.
    Use this as a bootstrap helper and do NOT commit the resulting file to git.
    Consider using terraform.tfvars or AWS Secrets Manager for production.
    """
    prefix_clean = prefix.rstrip("/")
    blocks = [
        "###############################################",
        "# GENERATED BY env_to_ssm.py                  #",
        "# ‚ö†Ô∏è  CONTAINS SENSITIVE DATA                 #",
        "# üö´ DO NOT COMMIT TO GIT                     #",
        "###############################################",
        "",
        "# Add this to your .gitignore:",
        "# secrets.tf",
        "# *.auto.tfvars",
        "",
    ]

    invalid_params = []
    for key, value in sorted(env_dict.items()):
        tf_name = normalize_name_for_tf(key)
        param_name = f"{prefix_clean}/{key}"

        # Validate parameter name
        if not validate_ssm_parameter_name(param_name):
            invalid_params.append((key, param_name))
            continue

        # Escape for HCL string literals
        # HCL uses \ as escape character, so we need to escape: \, ", $, %
        hcl_value = (
            value.replace("\\", "\\\\")  # Backslash must be first
            .replace('"', '\\"')  # Double quotes
            .replace("$", "$$")  # Dollar sign (for interpolation)
        )

        block = f'''resource "aws_ssm_parameter" "{tf_name}" {{
  name        = "{param_name}"
  type        = "SecureString"
  value       = "{hcl_value}"
  description = "Imported from .env - {key}"

  tags = {{
    managed-by = "terraform"
    source     = "env_to_ssm"
    env-key    = "{key}"
  }}

  lifecycle {{
    # Prevent accidental deletion
    prevent_destroy = false

    # Ignore changes to value after initial creation
    # Remove this if you want Terraform to manage updates
    # ignore_changes = [value]
  }}
}}

'''
        blocks.append(block)

    if invalid_params:
        warning = [
            "",
            "/*",
            " * WARNING: The following parameters have invalid names and were skipped:",
        ]
        for key, param_name in invalid_params:
            warning.append(f" *   - {key} -> {param_name}")
        warning.append(" */")
        blocks.extend(warning)

    # Add outputs for easy reference
    blocks.append("\n# Outputs for easy reference")
    blocks.append("# Uncomment if needed:")
    blocks.append("/*")
    for key in sorted(env_dict.keys()):
        tf_name = normalize_name_for_tf(key)
        if (key, f"{prefix_clean}/{key}") not in invalid_params:
            blocks.append(f'''output "{tf_name}_arn" {{
  description = "ARN of {key} parameter"
  value       = aws_ssm_parameter.{tf_name}.arn
  sensitive   = true
}}
''')
    blocks.append("*/")

    return "\n".join(blocks)


def main():
    parser = argparse.ArgumentParser(
        description="Convert .env to AWS SSM Parameter Store (bash or terraform).",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate bash script for dev environment
  %(prog)s -e .env -p /foundry/dev -f bash > put_dev_params.sh
  chmod +x put_dev_params.sh && ./put_dev_params.sh

  # Generate bash script with overwrite flag
  %(prog)s -e .env -p /foundry/dev -f bash --overwrite > update_params.sh

  # Generate Terraform file
  %(prog)s -e .env -p /foundry/prod -f tf > secrets.tf

  # Specify AWS region
  %(prog)s -e .env -p /foundry/dev -f bash --region us-west-2 > put_params.sh
        """,
    )
    parser.add_argument("--env-file", "-e", type=str, default=".env", help="Path to .env file (default: .env)")
    parser.add_argument(
        "--prefix", "-p", type=str, required=True, help="SSM path prefix, e.g. /foundry/dev or /myapp/prod"
    )
    parser.add_argument(
        "--format", "-f", choices=["bash", "tf"], default="bash", help="Output format: bash (script) or tf (terraform)"
    )
    parser.add_argument("--overwrite", action="store_true", help="For bash: include --overwrite in put-parameter calls")
    parser.add_argument("--region", "-r", type=str, help="AWS region (e.g., us-east-1, us-west-2)")
    parser.add_argument("--validate-only", action="store_true", help="Only validate .env file, don't generate output")
    args = parser.parse_args()

    env_path = Path(args.env_file)
    if not env_path.exists():
        print(f"‚ùå Error: .env file not found: {env_path}", file=sys.stderr)
        sys.exit(1)

    print(f"üìñ Parsing {env_path}...", file=sys.stderr)
    env_dict = parse_env_file(env_path)

    if not env_dict:
        print(f"‚ùå Error: No key=value pairs found in {env_path}", file=sys.stderr)
        sys.exit(1)

    print(f"‚úì Found {len(env_dict)} environment variables", file=sys.stderr)

    # Validate parameter names
    invalid_count = 0
    for key in env_dict.keys():
        param_name = f"{args.prefix.rstrip('/')}/{key}"
        if not validate_ssm_parameter_name(param_name):
            print(f"‚ö†Ô∏è  Warning: Invalid SSM parameter name: {param_name}", file=sys.stderr)
            invalid_count += 1

    if invalid_count > 0:
        print(f"‚ö†Ô∏è  {invalid_count} invalid parameter name(s) will be skipped", file=sys.stderr)

    if args.validate_only:
        print("‚úì Validation complete", file=sys.stderr)
        sys.exit(0)

    print(f"üî® Generating {args.format} output...", file=sys.stderr)

    if args.format == "bash":
        output = generate_bash(env_dict, args.prefix, overwrite=args.overwrite, region=args.region)
    else:
        output = generate_terraform(env_dict, args.prefix)

    print(output, end="")

    print("", file=sys.stderr)
    print("‚úì Done! Remember:", file=sys.stderr)
    if args.format == "bash":
        print("  1. Review the generated script before running", file=sys.stderr)
        print("  2. Verify AWS credentials: aws sts get-caller-identity", file=sys.stderr)
        print("  3. Make executable: chmod +x <output_file>", file=sys.stderr)
        print("  4. Run: ./<output_file>", file=sys.stderr)
    else:
        print("  1. DO NOT commit secrets.tf to git!", file=sys.stderr)
        print("  2. Add 'secrets.tf' to .gitignore", file=sys.stderr)
        print("  3. Review before applying: terraform plan", file=sys.stderr)
        print("  4. Apply: terraform apply", file=sys.stderr)


if __name__ == "__main__":
    main()
